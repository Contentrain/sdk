// Generated by Contentrain SQLite Generator
// @ts-nocheck

import type { ContentItem } from '@contentrain/sqlite-generator';
import type {
  QueryBuilder,
  QueryConfig,
  QueryOptions,
  QueryResult,
  WhereClause,
  OrderByClause,
  RelationOptions,
  IncludeClause,
} from '@contentrain/sqlite-generator';

// Base Types
export type ModelLocales<T extends string> = T;

export interface IBaseModel<T extends string | never = never> {
  id: string;
  created_at: string;
  updated_at: string;
  status: 'draft' | 'changed' | 'publish';
  translations?: T extends string
    ? Record<ModelLocales<T>, IBaseTranslation<T>>
    : never;
}

export interface IBaseTranslation<T extends string> {
  id: string;
  locale: ModelLocales<T>;
}

// ServicesItems Interface
export interface IServices extends IBaseModel<ModelLocales<'services'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  title: string;
  description?: string;
  image?: string;

  reference_id?: string;
  reference?: IReferences | null;
}

export interface IServicesTranslation extends IBaseTranslation<'services'> {
  title: string;
  description?: string;
  image?: string;
}

// ProcessItems Interface
export interface IProcesses extends IBaseModel<ModelLocales<'processes'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  title: string;
  description: string;
  icon: string;
}

export interface IProcessesTranslation extends IBaseTranslation<'processes'> {
  title: string;
  description: string;
  icon: string;
}

// TabItems Interface
export interface ITabitems extends IBaseModel<ModelLocales<'tabitems'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  link: string;
  description: string;
  image: string;

  category_id: string;
  category: IWorkcategories[] | null;
}

export interface ITabitemsTranslation extends IBaseTranslation<'tabitems'> {
  link: string;
  description: string;
  image: string;
}

// WorkItems Interface
export interface IWorkitems extends IBaseModel<ModelLocales<'workitems'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  title: string;
  image?: string;
  description: string;
  link: string;
  order: number;

  category_id: string;
  category: IWorkcategories | null;
}

export interface IWorkitemsTranslation extends IBaseTranslation<'workitems'> {
  title: string;
  image?: string;
  description: string;
  link: string;
  order: number;
}

// WorkCategories Interface
export interface IWorkcategories extends IBaseModel<ModelLocales<'workcategories'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  category: string;
  order: number;
}

export interface IWorkcategoriesTranslation extends IBaseTranslation<'workcategories'> {
  category: string;
  order: number;
}

// FaqItems Interface
export interface IFaqitems extends IBaseModel<ModelLocales<'faqitems'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  question: string;
  answer: string;
  order: number;
}

export interface IFaqitemsTranslation extends IBaseTranslation<'faqitems'> {
  question: string;
  answer: string;
  order: number;
}

// Sections Interface
export interface ISections extends IBaseModel<ModelLocales<'sections'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  title: string;
  description: string;
  buttontext?: string;
  buttonlink?: string;
  name: string;
  subtitle?: string;
}

export interface ISectionsTranslation extends IBaseTranslation<'sections'> {
  title: string;
  description: string;
  buttontext?: string;
  buttonlink?: string;
  name: string;
  subtitle?: string;
}

// SocialLinks Interface
export interface ISociallinks extends IBaseModel<never> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  link: string;
  icon: string;

  service_id?: string;
  service?: IServices | null;
}



// References Interface
export interface IReferences extends IBaseModel<never> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  logo: string;
}



// MetaTags Interface
export interface IMetaTags extends IBaseModel<ModelLocales<'meta-tags'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  name: string;
  content: string;
  description?: string;
}

export interface IMetaTagsTranslation extends IBaseTranslation<'meta-tags'> {
  name: string;
  content: string;
  description?: string;
}

// Testimonial Items Interface
export interface ITestimonialItems extends IBaseModel<ModelLocales<'testimonial-items'>> {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: string;
  name: string;
  description: string;
  title: string;
  image: string;

  creative-work_id: string;
  creative-work: IWorkitems | null;
}

export interface ITestimonialItemsTranslation extends IBaseTranslation<'testimonial-items'> {
  name: string;
  description: string;
  title: string;
  image: string;
}

// ServicesItems Query Types
export type ServicesWhereClause = WhereClause<IServices>;
export type ServicesOrderByClause = OrderByClause<IServices>;
export type ServicesRelationOptions = RelationOptions<IServices>;
export type ServicesIncludeClause = IncludeClause<IServices>;

export interface ServicesQueryConfig extends QueryConfig<IServices> {
  select?: Array<keyof IServices>;
  where?: ServicesWhereClause[];
  orderBy?: ServicesOrderByClause[];
  include?: ServicesIncludeClause;
}

export interface ServicesQueryBuilder extends QueryBuilder<IServices> {
  where: <K extends keyof IServices>(
    field: K,
    operator: OperatorForType<IServices[K]>,
    value: IServices[K] | IServices[K][],
  ) => this;

  include: <K extends keyof IServices>(
    relations: K | K[],
    options?: ServicesRelationOptions,
  ) => this;

  orderBy: (field: keyof IServices, direction?: 'asc' | 'desc') => this;
}

export interface ServicesRepository {
  query: () => ServicesQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<IServices | null>;
  findOne: (query: ServicesQueryConfig) => Promise<IServices | null>;
  findMany: (query: ServicesQueryConfig) => Promise<QueryResult<IServices>>;
  count: (query?: Omit<ServicesQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// ProcessItems Query Types
export type ProcessesWhereClause = WhereClause<IProcesses>;
export type ProcessesOrderByClause = OrderByClause<IProcesses>;
export type ProcessesRelationOptions = RelationOptions<IProcesses>;
export type ProcessesIncludeClause = IncludeClause<IProcesses>;

export interface ProcessesQueryConfig extends QueryConfig<IProcesses> {
  select?: Array<keyof IProcesses>;
  where?: ProcessesWhereClause[];
  orderBy?: ProcessesOrderByClause[];
  include?: ProcessesIncludeClause;
}

export interface ProcessesQueryBuilder extends QueryBuilder<IProcesses> {
  where: <K extends keyof IProcesses>(
    field: K,
    operator: OperatorForType<IProcesses[K]>,
    value: IProcesses[K] | IProcesses[K][],
  ) => this;

  include: <K extends keyof IProcesses>(
    relations: K | K[],
    options?: ProcessesRelationOptions,
  ) => this;

  orderBy: (field: keyof IProcesses, direction?: 'asc' | 'desc') => this;
}

export interface ProcessesRepository {
  query: () => ProcessesQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<IProcesses | null>;
  findOne: (query: ProcessesQueryConfig) => Promise<IProcesses | null>;
  findMany: (query: ProcessesQueryConfig) => Promise<QueryResult<IProcesses>>;
  count: (query?: Omit<ProcessesQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// TabItems Query Types
export type TabitemsWhereClause = WhereClause<ITabitems>;
export type TabitemsOrderByClause = OrderByClause<ITabitems>;
export type TabitemsRelationOptions = RelationOptions<ITabitems>;
export type TabitemsIncludeClause = IncludeClause<ITabitems>;

export interface TabitemsQueryConfig extends QueryConfig<ITabitems> {
  select?: Array<keyof ITabitems>;
  where?: TabitemsWhereClause[];
  orderBy?: TabitemsOrderByClause[];
  include?: TabitemsIncludeClause;
}

export interface TabitemsQueryBuilder extends QueryBuilder<ITabitems> {
  where: <K extends keyof ITabitems>(
    field: K,
    operator: OperatorForType<ITabitems[K]>,
    value: ITabitems[K] | ITabitems[K][],
  ) => this;

  include: <K extends keyof ITabitems>(
    relations: K | K[],
    options?: TabitemsRelationOptions,
  ) => this;

  orderBy: (field: keyof ITabitems, direction?: 'asc' | 'desc') => this;
}

export interface TabitemsRepository {
  query: () => TabitemsQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<ITabitems | null>;
  findOne: (query: TabitemsQueryConfig) => Promise<ITabitems | null>;
  findMany: (query: TabitemsQueryConfig) => Promise<QueryResult<ITabitems>>;
  count: (query?: Omit<TabitemsQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// WorkItems Query Types
export type WorkitemsWhereClause = WhereClause<IWorkitems>;
export type WorkitemsOrderByClause = OrderByClause<IWorkitems>;
export type WorkitemsRelationOptions = RelationOptions<IWorkitems>;
export type WorkitemsIncludeClause = IncludeClause<IWorkitems>;

export interface WorkitemsQueryConfig extends QueryConfig<IWorkitems> {
  select?: Array<keyof IWorkitems>;
  where?: WorkitemsWhereClause[];
  orderBy?: WorkitemsOrderByClause[];
  include?: WorkitemsIncludeClause;
}

export interface WorkitemsQueryBuilder extends QueryBuilder<IWorkitems> {
  where: <K extends keyof IWorkitems>(
    field: K,
    operator: OperatorForType<IWorkitems[K]>,
    value: IWorkitems[K] | IWorkitems[K][],
  ) => this;

  include: <K extends keyof IWorkitems>(
    relations: K | K[],
    options?: WorkitemsRelationOptions,
  ) => this;

  orderBy: (field: keyof IWorkitems, direction?: 'asc' | 'desc') => this;
}

export interface WorkitemsRepository {
  query: () => WorkitemsQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<IWorkitems | null>;
  findOne: (query: WorkitemsQueryConfig) => Promise<IWorkitems | null>;
  findMany: (query: WorkitemsQueryConfig) => Promise<QueryResult<IWorkitems>>;
  count: (query?: Omit<WorkitemsQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// WorkCategories Query Types
export type WorkcategoriesWhereClause = WhereClause<IWorkcategories>;
export type WorkcategoriesOrderByClause = OrderByClause<IWorkcategories>;
export type WorkcategoriesRelationOptions = RelationOptions<IWorkcategories>;
export type WorkcategoriesIncludeClause = IncludeClause<IWorkcategories>;

export interface WorkcategoriesQueryConfig extends QueryConfig<IWorkcategories> {
  select?: Array<keyof IWorkcategories>;
  where?: WorkcategoriesWhereClause[];
  orderBy?: WorkcategoriesOrderByClause[];
  include?: WorkcategoriesIncludeClause;
}

export interface WorkcategoriesQueryBuilder extends QueryBuilder<IWorkcategories> {
  where: <K extends keyof IWorkcategories>(
    field: K,
    operator: OperatorForType<IWorkcategories[K]>,
    value: IWorkcategories[K] | IWorkcategories[K][],
  ) => this;

  include: <K extends keyof IWorkcategories>(
    relations: K | K[],
    options?: WorkcategoriesRelationOptions,
  ) => this;

  orderBy: (field: keyof IWorkcategories, direction?: 'asc' | 'desc') => this;
}

export interface WorkcategoriesRepository {
  query: () => WorkcategoriesQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<IWorkcategories | null>;
  findOne: (query: WorkcategoriesQueryConfig) => Promise<IWorkcategories | null>;
  findMany: (query: WorkcategoriesQueryConfig) => Promise<QueryResult<IWorkcategories>>;
  count: (query?: Omit<WorkcategoriesQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// FaqItems Query Types
export type FaqitemsWhereClause = WhereClause<IFaqitems>;
export type FaqitemsOrderByClause = OrderByClause<IFaqitems>;
export type FaqitemsRelationOptions = RelationOptions<IFaqitems>;
export type FaqitemsIncludeClause = IncludeClause<IFaqitems>;

export interface FaqitemsQueryConfig extends QueryConfig<IFaqitems> {
  select?: Array<keyof IFaqitems>;
  where?: FaqitemsWhereClause[];
  orderBy?: FaqitemsOrderByClause[];
  include?: FaqitemsIncludeClause;
}

export interface FaqitemsQueryBuilder extends QueryBuilder<IFaqitems> {
  where: <K extends keyof IFaqitems>(
    field: K,
    operator: OperatorForType<IFaqitems[K]>,
    value: IFaqitems[K] | IFaqitems[K][],
  ) => this;

  include: <K extends keyof IFaqitems>(
    relations: K | K[],
    options?: FaqitemsRelationOptions,
  ) => this;

  orderBy: (field: keyof IFaqitems, direction?: 'asc' | 'desc') => this;
}

export interface FaqitemsRepository {
  query: () => FaqitemsQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<IFaqitems | null>;
  findOne: (query: FaqitemsQueryConfig) => Promise<IFaqitems | null>;
  findMany: (query: FaqitemsQueryConfig) => Promise<QueryResult<IFaqitems>>;
  count: (query?: Omit<FaqitemsQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// Sections Query Types
export type SectionsWhereClause = WhereClause<ISections>;
export type SectionsOrderByClause = OrderByClause<ISections>;
export type SectionsRelationOptions = RelationOptions<ISections>;
export type SectionsIncludeClause = IncludeClause<ISections>;

export interface SectionsQueryConfig extends QueryConfig<ISections> {
  select?: Array<keyof ISections>;
  where?: SectionsWhereClause[];
  orderBy?: SectionsOrderByClause[];
  include?: SectionsIncludeClause;
}

export interface SectionsQueryBuilder extends QueryBuilder<ISections> {
  where: <K extends keyof ISections>(
    field: K,
    operator: OperatorForType<ISections[K]>,
    value: ISections[K] | ISections[K][],
  ) => this;

  include: <K extends keyof ISections>(
    relations: K | K[],
    options?: SectionsRelationOptions,
  ) => this;

  orderBy: (field: keyof ISections, direction?: 'asc' | 'desc') => this;
}

export interface SectionsRepository {
  query: () => SectionsQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<ISections | null>;
  findOne: (query: SectionsQueryConfig) => Promise<ISections | null>;
  findMany: (query: SectionsQueryConfig) => Promise<QueryResult<ISections>>;
  count: (query?: Omit<SectionsQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// SocialLinks Query Types
export type SociallinksWhereClause = WhereClause<ISociallinks>;
export type SociallinksOrderByClause = OrderByClause<ISociallinks>;
export type SociallinksRelationOptions = RelationOptions<ISociallinks>;
export type SociallinksIncludeClause = IncludeClause<ISociallinks>;

export interface SociallinksQueryConfig extends QueryConfig<ISociallinks> {
  select?: Array<keyof ISociallinks>;
  where?: SociallinksWhereClause[];
  orderBy?: SociallinksOrderByClause[];
  include?: SociallinksIncludeClause;
}

export interface SociallinksQueryBuilder extends QueryBuilder<ISociallinks> {
  where: <K extends keyof ISociallinks>(
    field: K,
    operator: OperatorForType<ISociallinks[K]>,
    value: ISociallinks[K] | ISociallinks[K][],
  ) => this;

  include: <K extends keyof ISociallinks>(
    relations: K | K[],
    options?: SociallinksRelationOptions,
  ) => this;

  orderBy: (field: keyof ISociallinks, direction?: 'asc' | 'desc') => this;
}

export interface SociallinksRepository {
  query: () => SociallinksQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<ISociallinks | null>;
  findOne: (query: SociallinksQueryConfig) => Promise<ISociallinks | null>;
  findMany: (query: SociallinksQueryConfig) => Promise<QueryResult<ISociallinks>>;
  count: (query?: Omit<SociallinksQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// References Query Types
export type ReferencesWhereClause = WhereClause<IReferences>;
export type ReferencesOrderByClause = OrderByClause<IReferences>;
export type ReferencesRelationOptions = RelationOptions<IReferences>;
export type ReferencesIncludeClause = IncludeClause<IReferences>;

export interface ReferencesQueryConfig extends QueryConfig<IReferences> {
  select?: Array<keyof IReferences>;
  where?: ReferencesWhereClause[];
  orderBy?: ReferencesOrderByClause[];
  include?: ReferencesIncludeClause;
}

export interface ReferencesQueryBuilder extends QueryBuilder<IReferences> {
  where: <K extends keyof IReferences>(
    field: K,
    operator: OperatorForType<IReferences[K]>,
    value: IReferences[K] | IReferences[K][],
  ) => this;

  include: <K extends keyof IReferences>(
    relations: K | K[],
    options?: ReferencesRelationOptions,
  ) => this;

  orderBy: (field: keyof IReferences, direction?: 'asc' | 'desc') => this;
}

export interface ReferencesRepository {
  query: () => ReferencesQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<IReferences | null>;
  findOne: (query: ReferencesQueryConfig) => Promise<IReferences | null>;
  findMany: (query: ReferencesQueryConfig) => Promise<QueryResult<IReferences>>;
  count: (query?: Omit<ReferencesQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// MetaTags Query Types
export type MetaTagsWhereClause = WhereClause<IMetaTags>;
export type MetaTagsOrderByClause = OrderByClause<IMetaTags>;
export type MetaTagsRelationOptions = RelationOptions<IMetaTags>;
export type MetaTagsIncludeClause = IncludeClause<IMetaTags>;

export interface MetaTagsQueryConfig extends QueryConfig<IMetaTags> {
  select?: Array<keyof IMetaTags>;
  where?: MetaTagsWhereClause[];
  orderBy?: MetaTagsOrderByClause[];
  include?: MetaTagsIncludeClause;
}

export interface MetaTagsQueryBuilder extends QueryBuilder<IMetaTags> {
  where: <K extends keyof IMetaTags>(
    field: K,
    operator: OperatorForType<IMetaTags[K]>,
    value: IMetaTags[K] | IMetaTags[K][],
  ) => this;

  include: <K extends keyof IMetaTags>(
    relations: K | K[],
    options?: MetaTagsRelationOptions,
  ) => this;

  orderBy: (field: keyof IMetaTags, direction?: 'asc' | 'desc') => this;
}

export interface MetaTagsRepository {
  query: () => MetaTagsQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<IMetaTags | null>;
  findOne: (query: MetaTagsQueryConfig) => Promise<IMetaTags | null>;
  findMany: (query: MetaTagsQueryConfig) => Promise<QueryResult<IMetaTags>>;
  count: (query?: Omit<MetaTagsQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}

// Testimonial Items Query Types
export type TestimonialItemsWhereClause = WhereClause<ITestimonialItems>;
export type TestimonialItemsOrderByClause = OrderByClause<ITestimonialItems>;
export type TestimonialItemsRelationOptions = RelationOptions<ITestimonialItems>;
export type TestimonialItemsIncludeClause = IncludeClause<ITestimonialItems>;

export interface TestimonialItemsQueryConfig extends QueryConfig<ITestimonialItems> {
  select?: Array<keyof ITestimonialItems>;
  where?: TestimonialItemsWhereClause[];
  orderBy?: TestimonialItemsOrderByClause[];
  include?: TestimonialItemsIncludeClause;
}

export interface TestimonialItemsQueryBuilder extends QueryBuilder<ITestimonialItems> {
  where: <K extends keyof ITestimonialItems>(
    field: K,
    operator: OperatorForType<ITestimonialItems[K]>,
    value: ITestimonialItems[K] | ITestimonialItems[K][],
  ) => this;

  include: <K extends keyof ITestimonialItems>(
    relations: K | K[],
    options?: TestimonialItemsRelationOptions,
  ) => this;

  orderBy: (field: keyof ITestimonialItems, direction?: 'asc' | 'desc') => this;
}

export interface TestimonialItemsRepository {
  query: () => TestimonialItemsQueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<ITestimonialItems | null>;
  findOne: (query: TestimonialItemsQueryConfig) => Promise<ITestimonialItems | null>;
  findMany: (query: TestimonialItemsQueryConfig) => Promise<QueryResult<ITestimonialItems>>;
  count: (query?: Omit<TestimonialItemsQueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}
