import type { ContentrainOptions } from '../../../module';
import type { FieldMetadata, ModelMetadata } from '../../../types';
import fs from 'node:fs';
import path, { join } from 'node:path';
import { ContentrainError, ERROR_CODES } from '../utils/errors';

export class ContentrainTypeGenerator {
    constructor(private options: ContentrainOptions) {}
    async generateTypes(): Promise<string> {
        try {
            const modelsDir = join(this.options.path || 'contentrain', 'models');

            // Get model files
            const modelFiles = this.getModelFiles(modelsDir);
            if (modelFiles.length === 0) {
                return this.getEmptyTypeDefinition();
            }

            // Get metadata
            const metadata = this.getMetadata(modelsDir);
            if (metadata.length === 0) {
                throw new ContentrainError({
                    code: ERROR_CODES.METADATA_NOT_FOUND,
                    message: 'metadata.json not found or invalid',
                });
            }

            // Generate types
            const { baseTypes, queryTypes } = this.processModelFiles(modelsDir, modelFiles, metadata);

            // Create type definitions
            const typeDefinitions = this.initializeTypeDefinitions() + baseTypes + queryTypes;

            console.info('[Contentrain] Successfully generated type definitions.');

            // Return the generated type definitions
            return typeDefinitions;
        }
        catch (error) {
            if (error instanceof ContentrainError) {
                console.error(`[Contentrain] Type generation failed: ${error.code} - ${error.message}`);
            }
            else {
                console.error('[Contentrain] Type generation failed:', error);
            }
            return this.getEmptyTypeDefinition();
        }
    }

    private detectModelLanguages(contentPath: string, modelMetadata: ModelMetadata): string[] {
        if (!modelMetadata.localization) {
            return [];
        }

        const languages = new Set<string>();
        const modelPath = join(contentPath || 'contentrain', modelMetadata.modelId);

        try {
            if (fs.existsSync(modelPath)) {
                const files = fs.readdirSync(modelPath);
                files.forEach((file) => {
                    if (file.endsWith('.json')) {
                        const lang = file.replace('.json', '');
                        languages.add(lang);
                    }
                });
            }
            if (languages.size === 0) {
                languages.add(this.options.defaultLocale || 'en');
            }

            return Array.from(languages);
        }
        catch (error) {
            console.warn(`[Contentrain] Error detecting languages for model ${modelMetadata.modelId}:`, error);
            return [this.options.defaultLocale || 'en'];
        }
    }

    private getEmptyTypeDefinition(): string {
        return `// Generated by @contentrain/nuxt-json
// No models found or error occurred during type generation

// Base content types for reference
interface ContentBase {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: 'publish' | 'draft' | 'changed';
  [key: string]: unknown;
}

interface LocalizedContentBase extends ContentBase {
  _lang: string;
}

// Query result types
interface QueryResultBase<T> {
  data: T[];
  total: number;
  pagination: {
    limit: number;
    offset: number;
    total: number;
  };
}

interface SingleQueryResultBase<T> {
  data: T;
  total: number;
  pagination: {
    limit: number;
    offset: number;
    total: number;
  };
}

// No model types available
`;
    }

    private getModelFiles(modelsDir: string): string[] {
        try {
            if (!fs.existsSync(modelsDir)) {
                throw new ContentrainError({
                    code: ERROR_CODES.MODELS_DIR_NOT_FOUND,
                    message: `Models directory not found: ${modelsDir}`,
                });
            }

            return fs.readdirSync(modelsDir)
                .filter(file => file.endsWith('.json') && file !== 'metadata.json');
        }
        catch (error) {
            if (error instanceof ContentrainError) {
                throw error;
            }
            console.error('[Contentrain] Error reading model files:', error);
            return [];
        }
    }

    private getMetadata(modelsDir: string): ModelMetadata[] {
        try {
            const metadataPath = path.join(modelsDir, 'metadata.json');
            if (!fs.existsSync(metadataPath)) {
                throw new ContentrainError({
                    code: ERROR_CODES.METADATA_NOT_FOUND,
                    message: `Metadata file not found: ${metadataPath}`,
                });
            }

            const content = fs.readFileSync(metadataPath, 'utf-8');
            const metadata = JSON.parse(content);

            if (!Array.isArray(metadata)) {
                throw new ContentrainError({
                    code: ERROR_CODES.METADATA_NOT_FOUND,
                    message: 'Metadata is not a valid array',
                });
            }

            return metadata;
        }
        catch (error) {
            if (error instanceof ContentrainError) {
                throw error;
            }
            console.error('[Contentrain] Error reading metadata:', error);
            return [];
        }
    }

    private initializeTypeDefinitions(): string {
        const typeDefinitions = `// Automatically generated by @contentrain/nuxt-json
// Do not edit this file manually

// Base content types for reference
interface ContentBase {
  ID: string;
  createdAt: string;
  updatedAt: string;
  status: 'publish' | 'draft' | 'changed';
  [key: string]: unknown;
}

interface LocalizedContentBase extends ContentBase {
  _lang: string;
}

// Query result types
interface QueryResultBase<T> {
  data: T[];
  total: number;
  pagination: {
    limit: number;
    offset: number;
    total: number;
  };
}

interface SingleQueryResultBase<T> {
  data: T;
  total: number;
  pagination: {
    limit: number;
    offset: number;
    total: number;
  };
}

`;

        return typeDefinitions;
    }

    private processModelFiles(
        modelsDir: string,
        modelFiles: string[],
        metadata: ModelMetadata[],
    ): { baseTypes: string, queryTypes: string } {
        let baseTypes = '';
        let queryTypes = '';

        modelFiles.forEach((file) => {
            try {
                const modelId = path.basename(file, '.json');
                const modelPath = path.join(modelsDir, file);
                const modelContent: FieldMetadata[] = JSON.parse(fs.readFileSync(modelPath, 'utf-8'));
                const modelMetadata = metadata.find(m => m.modelId === modelId);

                if (!modelMetadata) {
                    console.warn(`[Contentrain] Model metadata not found: ${modelId}`);
                    return;
                }

                // Her model için dil tipini belirle
                const modelLanguages = this.detectModelLanguages(this.options.path || 'contentrain', modelMetadata);

                // Base Type Generation
                const interfaceName = this.formatInterfaceName(modelMetadata);
                const { typeDefinition } = this.generateTypeForModel(modelContent, metadata, modelMetadata.localization, modelLanguages);

                // Determine if model is localized
                const baseType = modelMetadata.localization ? 'LocalizedContentBase' : 'ContentBase';

                // Artık özel dil tipi tanımlamıyoruz
                baseTypes += `export interface ${interfaceName} extends ${baseType} ${typeDefinition}\n\n`;

                // Generate query helper types
                queryTypes += this.generateQueryHelperTypes(interfaceName);
            }
            catch (error) {
                console.error(`[Contentrain] Error processing model file ${file}:`, error);
            }
        });

        return { baseTypes, queryTypes };
    }

    private generateTypeForModel(
        modelFields: FieldMetadata[],
        metadata: ModelMetadata[],
        isLocalized: boolean,
        languages: string[] = [],
    ): { typeDefinition: string, relations: Record<string, { model: string, type: string }> } {
        let typeDefinition = '{\n';
        const relations: Record<string, { model: string, type: string }> = {};
        const relationFields: string[] = [];

        // Add _lang field for localized models with model-specific language type
        if (isLocalized && languages.length > 0) {
            // Doğrudan dil değerlerini kullan, özel tip tanımlaması yapma
            typeDefinition += `  _lang: ${languages.map(lang => `'${lang}'`).join(' | ')};\n`;
        }

        modelFields.forEach((field) => {
            if (!['ID', 'createdAt', 'updatedAt', 'status', '_lang'].includes(field.fieldId)) {
                if (field.fieldType === 'relation' && field.options?.reference) {
                    const relatedModelId = field.options.reference.form.reference.value;
                    const relatedModel = metadata.find(m => m.modelId === relatedModelId);

                    if (relatedModel) {
                        const relatedInterfaceName = this.formatInterfaceName(relatedModel);
                        relations[field.fieldId] = {
                            model: relatedInterfaceName,
                            type: field.componentId || 'one-to-one',
                        };

                        // Add property for relation IDs - Doğrudan fieldId kullan
                        typeDefinition += `  "${field.fieldId}": string${field.componentId === 'one-to-many' ? '[]' : ''};\n`;
                        relationFields.push(field.fieldId);
                    }
                }
                else {
                    const fieldType = this.determineTypeScriptType(field);
                    const isRequired = this.isFieldRequired(field);
                    // Doğrudan fieldId kullan, tırnak içinde yaz
                    typeDefinition += `  "${field.fieldId}"${isRequired ? '' : '?'}: ${fieldType};\n`;
                }
            }
        });

        // Add _relations object if there are relations
        if (relationFields.length > 0) {
            typeDefinition += '\n  _relations?: {\n';
            relationFields.forEach((fieldId) => {
                const relation = relations[fieldId];
                // Doğrudan fieldId kullan, tırnak içinde yaz
                typeDefinition += `    "${fieldId}"?: ${relation.model}${relation.type === 'one-to-many' ? '[]' : ''};\n`;
            });
            typeDefinition += '  };\n';
        }

        typeDefinition += '}';
        return { typeDefinition, relations };
    }

    private generateQueryHelperTypes(interfaceName: string): string {
        return `// Query result types for ${interfaceName}
export type ${interfaceName}QueryResult = QueryResultBase<${interfaceName}>;
export type ${interfaceName}SingleResult = SingleQueryResultBase<${interfaceName}>;\n\n`;
    }

    private determineTypeScriptType(field: FieldMetadata): string {
        const typeMap: Record<string, string> = {
            string: 'string',
            number: 'number',
            boolean: 'boolean',
            date: 'string',
            media: 'string',
            relation: field.componentId === 'one-to-many' ? 'string[]' : 'string',
            array: 'any[]', // Array tipi için varsayılan any[]
        };

        return typeMap[field.fieldType] || 'unknown';
    }

    private formatInterfaceName(metadata: ModelMetadata): string {
        const baseName = metadata.name || metadata.modelId;

        // Boşlukları kaldır ve PascalCase'e çevir
        return baseName
            .replace(/\s+/g, '') // Boşlukları kaldır
            .replace(/[-_]([a-z])/g, (_, letter) => letter.toUpperCase()) // kebab-case veya snake_case'i PascalCase'e çevir
            .replace(/^[a-z]/, letter => letter.toUpperCase()); // İlk harfi büyük yap
    }

    private isFieldRequired(field: FieldMetadata): boolean {
        return field.validations?.['required-field']?.value === true;
    }
}
