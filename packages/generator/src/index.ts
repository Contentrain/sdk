import type { ContentrainField, ContentrainModelMetadata } from '@contentrain/types';

export interface GeneratorConfig {
  output?: string
}

export class ContentrainGenerator {
  constructor() {}

  private getTypeForField(field: ContentrainField): string {
    switch (field.type) {
      case 'string':
        return 'string';
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'date':
        return 'string';
      case 'media':
        return 'string';
      case 'relation':
        return field.componentId === 'one-to-one' ? 'string' : 'string[]';
      default:
        return 'string';
    }
  }

  private formatInterfaceName(metadata: ContentrainModelMetadata): string {
    if (!metadata.name && !metadata.modelId) {
      throw new Error('Model must have either name or modelId');
    }

    // Önce name alanını kontrol et, yoksa modelId'yi kullan
    const baseName = metadata.name || metadata.modelId;
    // Boşlukları kaldır ve camelCase'e çevir
    return `I${baseName.replace(/\s+/g, '').replace(/-./g, x => x[1].toUpperCase())}`;
  }

  async generate(models: ContentrainModelMetadata[]): Promise<string> {
    let output = '// Generated by @contentrain/generator\n\n';

    // Generate base type
    output += 'export interface BaseContentrainModel {\n';
    output += '  ID: string;\n';
    output += '  createdAt: string;\n';
    output += '  updatedAt: string;\n';
    output += '  status: \'draft\' | \'changed\' | \'publish\';\n';
    output += '  scheduled: boolean;\n';
    output += '}\n\n';

    // Generate model types
    for (const model of models) {
      const interfaceName = this.formatInterfaceName(model);
      output += `export interface ${interfaceName} extends BaseContentrainModel {\n`;

      for (const field of model.fields) {
        if (!['ID', 'createdAt', 'updatedAt', 'status'].includes(field.id)) {
          const type = this.getTypeForField(field);
          const isOptional = !field.required;
          output += `  ${field.id}${isOptional ? '?' : ''}: ${type};\n`;
        }
      }
      output += '}\n\n';
    }

    // Generate model map
    output += 'export type ContentrainTypeMap = {\n';
    for (const model of models) {
      output += `  '${model.modelId}': ${this.formatInterfaceName(model)};\n`;
    }
    output += '};\n';

    return output;
  }
}
