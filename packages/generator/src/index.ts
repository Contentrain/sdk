import type { ContentrainField, ContentrainModelMetadata } from '@contentrain/types';

export interface GeneratorConfig {
  output?: string
}

export class ContentrainGenerator {
  constructor() {}

  private getTypeForField(field: ContentrainField): string {
    switch (field.type) {
      case 'string':
        return 'string';
      case 'number':
        return 'number';
      case 'boolean':
        return 'boolean';
      case 'date':
        return 'string';
      case 'media':
        return 'string';
      case 'relation':
        return field.componentId === 'one-to-one' ? 'string' : 'string[]';
      default:
        return 'string';
    }
  }

  private capitalizeFirstLetter(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  async generate(models: ContentrainModelMetadata[]): Promise<string> {
    let output = '// Generated by @contentrain/generator\n\n';

    // Generate base type
    output += 'export interface ContentrainBaseModel {\n';
    output += '  ID: string;\n';
    output += '  createdAt: string;\n';
    output += '  updatedAt: string;\n';
    output += '  status: \'draft\' | \'changed\' | \'publish\';\n';
    output += '  scheduled: boolean;\n';
    output += '}\n\n';

    // Generate model types
    for (const model of models) {
      const interfaceName = this.capitalizeFirstLetter(model.modelId.replace(/-/g, ''));
      output += `export interface ${interfaceName} extends ContentrainBaseModel {\n`;

      for (const field of model.fields) {
        if (!['ID', 'createdAt', 'updatedAt', 'status'].includes(field.id)) {
          const type = this.getTypeForField(field);
          const isOptional = !field.required;
          output += `  ${field.id}${isOptional ? '?' : ''}: ${type};\n`;
        }
      }
      output += '}\n\n';
    }

    // Generate model map
    output += 'export type ContentrainTypeMap = {\n';
    for (const model of models) {
      output += `  '${model.modelId}': ${this.capitalizeFirstLetter(model.modelId.replace(/-/g, ''))};\n`;
    }
    output += '};\n';

    return output;
  }
}
