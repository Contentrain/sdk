import type { ModelConfig, ModelField, RelationType } from '../types/model';
import { writeFile } from 'node:fs/promises';
import { FieldNormalizer } from '../normalizer/FieldNormalizer';
import { TYPE_MAPPING } from '../types/model';

export class TypeGenerator {
  private fieldNormalizer: FieldNormalizer;

  constructor(private typesPath: string) {
    this.fieldNormalizer = new FieldNormalizer();
  }

  /**
   * Tip tanımlarını oluşturur
   * @param models Model konfigürasyonları
   */
  async generateTypes(models: ModelConfig[]): Promise<void> {
    const declarations = this.generateDeclarations(models);
    await writeFile(this.typesPath, declarations, 'utf-8');
  }

  /**
   * Tip tanımlarını oluşturur
   * @param models Model konfigürasyonları
   * @returns Tip tanımları
   */
  private generateDeclarations(models: ModelConfig[]): string {
    const imports = this.generateImports();
    const interfaces = models.map(model => this.generateModelInterface(model)).join('\n\n');
    const queryTypes = models.map(model => this.generateQueryType(model)).join('\n\n');

    return `${imports}\n\n${interfaces}\n\n${queryTypes}\n`;
  }

  /**
   * İçe aktarmaları oluşturur
   * @returns İçe aktarma tanımları
   */
  private generateImports(): string {
    return `// Generated by Contentrain SQLite Generator

export type ModelLocales<T extends string> = T;

export interface IBaseModel<T extends string | never = never> {
  id: string;
  created_at: string;
  updated_at: string;
  status: 'draft' | 'changed' | 'publish';
  translations?: T extends string
    ? Record<ModelLocales<T>, IBaseTranslation<T>>
    : never;
}

export interface IBaseTranslation<T extends string> {
  id: string;
  locale: ModelLocales<T>;
}`;
  }

  /**
   * Model arayüzünü oluşturur
   * @param model Model konfigürasyonu
   * @returns Model arayüzü
   */
  private generateModelInterface(model: ModelConfig): string {
    const localeType = model.localization ? `ModelLocales<'${model.id}'>` : 'never';
    const fields = this.generateFields(model.fields);
    const relationFields = this.generateRelationFields(model);

    return `export interface I${this.pascalCase(model.id)} extends IBaseModel<${localeType}> {
  ${fields}${relationFields ? `\n\n  ${relationFields}` : ''}
}

${model.localization ? this.generateTranslationInterface(model) : ''}`;
  }

  /**
   * İlişki alanlarını oluşturur
   * @param model Model konfigürasyonu
   * @returns İlişki alanları
   */
  private generateRelationFields(model: ModelConfig): string {
    const relationFields = model.fields.filter(field => field.fieldType === 'relation');
    if (!relationFields.length)
      return '';

    return relationFields
      .map((field) => {
        const targetModel = field.options?.reference?.form?.reference?.value;
        if (!targetModel)
          return '';

        const isOneToMany = field.componentId === 'one-to-many';
        const typeName = `I${this.pascalCase(targetModel)}`;

        return `${field.fieldId}: ${isOneToMany ? `${typeName}[]` : typeName} | null;`;
      })
      .filter(Boolean)
      .join('\n  ');
  }

  /**
   * Alanları oluşturur
   * @param fields Alan listesi
   * @returns Alan tanımları
   */
  private generateFields(fields: ModelField[]): string {
    return fields
      .filter(field => field.fieldType !== 'relation')
      .map((field) => {
        const type = TYPE_MAPPING[field.componentId] || 'unknown';
        const isRequired = field.validations?.['required-field']?.value;
        return `${field.fieldId}${isRequired ? '' : '?'}: ${type};`;
      })
      .join('\n  ');
  }

  /**
   * Çeviri arayüzünü oluşturur
   * @param model Model konfigürasyonu
   * @returns Çeviri arayüzü
   */
  private generateTranslationInterface(model: ModelConfig): string {
    const localizedFields = model.fields
      .filter(field => field.localized)
      .map((field) => {
        const type = TYPE_MAPPING[field.componentId] || 'unknown';
        const isRequired = field.validations?.['required-field']?.value;
        return `${field.fieldId}${isRequired ? '' : '?'}: ${type};`;
      })
      .join('\n  ');

    return `export interface I${this.pascalCase(model.id)}Translation extends IBaseTranslation<'${model.id}'> {
  ${localizedFields}
}`;
  }

  /**
   * Sorgu tipini oluşturur
   * @param model Model konfigürasyonu
   * @returns Sorgu tipi
   */
  private generateQueryType(model: ModelConfig): string {
    return `export type ${this.pascalCase(model.id)}Query = {
  [K in keyof I${this.pascalCase(model.id)}]?: I${this.pascalCase(model.id)}[K];
};`;
  }

  /**
   * Pascal case dönüşümü yapar
   * @param str Dönüştürülecek metin
   * @returns Pascal case metin
   */
  private pascalCase(str: string): string {
    return str
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}
