import type { ModelConfig, ModelField, RelationType } from '../types/model';
import { writeFile } from 'node:fs/promises';
import { FieldNormalizer } from '../normalizer/FieldNormalizer';
import { TYPE_MAPPING } from '../types/model';

export class TypeGenerator {
  private fieldNormalizer: FieldNormalizer;

  constructor(private typesPath: string) {
    this.fieldNormalizer = new FieldNormalizer();
  }

  /**
   * Tip tanımlarını oluşturur
   */
  async generateTypes(models: ModelConfig[]): Promise<void> {
    const declarations = this.generateDeclarations(models);
    await writeFile(this.typesPath, declarations, 'utf-8');
  }

  /**
   * Tip tanımlarını oluşturur
   */
  private generateDeclarations(models: ModelConfig[]): string {
    const imports = this.generateImports();
    const baseTypes = this.generateBaseTypes();
    const interfaces = models.map(model => this.generateModelInterface(model)).join('\n\n');
    const queryTypes = models.map(model => this.generateQueryTypes(model)).join('\n\n');

    return `${imports}\n\n${baseTypes}\n\n${interfaces}\n\n${queryTypes}\n`;
  }

  /**
   * İçe aktarmaları oluşturur
   */
  private generateImports(): string {
    return `// Generated by Contentrain SQLite Generator
// @ts-nocheck

import type { ContentItem } from '@contentrain/sqlite-generator';
import type {
  QueryBuilder,
  QueryConfig,
  QueryOptions,
  QueryResult,
  WhereClause,
  OrderByClause,
  RelationOptions,
  IncludeClause,
} from '@contentrain/sqlite-generator';`;
  }

  /**
   * Temel tipleri oluşturur
   */
  private generateBaseTypes(): string {
    return `// Base Types
export type ModelLocales<T extends string> = T;

export interface IBaseModel<T extends string | never = never> {
  id: string;
  created_at: string;
  updated_at: string;
  status: 'draft' | 'changed' | 'publish';
  translations?: T extends string
    ? Record<ModelLocales<T>, IBaseTranslation<T>>
    : never;
}

export interface IBaseTranslation<T extends string> {
  id: string;
  locale: ModelLocales<T>;
}`;
  }

  /**
   * Model arayüzünü oluşturur
   */
  private generateModelInterface(model: ModelConfig): string {
    const localeType = model.localization ? `ModelLocales<'${model.id}'>` : 'never';
    const fields = this.generateFields(model.fields);
    const relationFields = this.generateRelationFields(model);

    return `// ${model.name} Interface
export interface I${this.pascalCase(model.id)} extends IBaseModel<${localeType}> {
  ${fields}${relationFields ? `\n\n  ${relationFields}` : ''}
}

${model.localization ? this.generateTranslationInterface(model) : ''}`;
  }

  /**
   * Sorgu tiplerini oluşturur
   */
  private generateQueryTypes(model: ModelConfig): string {
    const modelName = this.pascalCase(model.id);
    const interfaceName = `I${modelName}`;

    return `// ${model.name} Query Types
export type ${modelName}WhereClause = WhereClause<${interfaceName}>;
export type ${modelName}OrderByClause = OrderByClause<${interfaceName}>;
export type ${modelName}RelationOptions = RelationOptions<${interfaceName}>;
export type ${modelName}IncludeClause = IncludeClause<${interfaceName}>;

export interface ${modelName}QueryConfig extends QueryConfig<${interfaceName}> {
  select?: Array<keyof ${interfaceName}>;
  where?: ${modelName}WhereClause[];
  orderBy?: ${modelName}OrderByClause[];
  include?: ${modelName}IncludeClause;
}

export interface ${modelName}QueryBuilder extends QueryBuilder<${interfaceName}> {
  where: <K extends keyof ${interfaceName}>(
    field: K,
    operator: OperatorForType<${interfaceName}[K]>,
    value: ${interfaceName}[K] | ${interfaceName}[K][],
  ) => this;

  include: <K extends keyof ${interfaceName}>(
    relations: K | K[],
    options?: ${modelName}RelationOptions,
  ) => this;

  orderBy: (field: keyof ${interfaceName}, direction?: 'asc' | 'desc') => this;
}

export interface ${modelName}Repository {
  query: () => ${modelName}QueryBuilder;
  findById: (id: string, options?: QueryOptions) => Promise<${interfaceName} | null>;
  findOne: (query: ${modelName}QueryConfig) => Promise<${interfaceName} | null>;
  findMany: (query: ${modelName}QueryConfig) => Promise<QueryResult<${interfaceName}>>;
  count: (query?: Omit<${modelName}QueryConfig, 'pagination' | 'orderBy'>) => Promise<number>;
}`;
  }

  /**
   * Alanları oluşturur
   */
  private generateFields(fields: ModelField[]): string {
    return fields
      .filter(field => field.fieldType !== 'relation')
      .map((field) => {
        const type = this.getTypeScriptType(field);
        const isRequired = field.validations?.['required-field']?.value;
        return `${field.fieldId}${isRequired ? '' : '?'}: ${type};`;
      })
      .join('\n  ');
  }

  /**
   * İlişki alanlarını oluşturur
   */
  private generateRelationFields(model: ModelConfig): string {
    const relationFields = model.fields.filter(field => field.fieldType === 'relation');
    if (!relationFields.length)
      return '';

    return relationFields
      .map((field) => {
        const targetModel = field.options?.reference?.form?.reference?.value;
        if (!targetModel)
          return '';

        const isOneToMany = field.componentId === 'one-to-many';
        const typeName = `I${this.pascalCase(targetModel)}`;
        const fieldName = field.fieldId;

        return [
          `${fieldName}_id${field.validations?.['required-field']?.value ? '' : '?'}: string;`,
          `${fieldName}${field.validations?.['required-field']?.value ? '' : '?'}: ${isOneToMany ? `${typeName}[]` : typeName} | null;`,
        ].join('\n  ');
      })
      .filter(Boolean)
      .join('\n\n  ');
  }

  /**
   * Çeviri arayüzünü oluşturur
   */
  private generateTranslationInterface(model: ModelConfig): string {
    const localizedFields = model.fields
      .filter(field => field.localized)
      .map((field) => {
        const type = this.getTypeScriptType(field);
        const isRequired = field.validations?.['required-field']?.value;
        return `${field.fieldId}${isRequired ? '' : '?'}: ${type};`;
      })
      .join('\n  ');

    return `export interface I${this.pascalCase(model.id)}Translation extends IBaseTranslation<'${model.id}'> {
  ${localizedFields}
}`;
  }

  /**
   * TypeScript tipini alır
   */
  private getTypeScriptType(field: ModelField): string {
    const baseType = TYPE_MAPPING[field.componentId] || 'unknown';
    const isArray = field.componentId === 'select';
    return isArray ? `${baseType}[]` : baseType;
  }

  /**
   * Pascal case dönüşümü yapar
   */
  private pascalCase(str: string): string {
    return str
      .split(/[-_]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}
