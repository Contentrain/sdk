import { readFile, writeFile, mkdir } from 'node:fs/promises'
import { join, dirname } from 'node:path'
import type { IGenerateTypesOptions, IGenerateTypesResult } from '../types/base'
import { CONTENTRAIN_PATHS } from '../types/runtime'
import { watch } from 'node:fs'
import { pluginManager } from '../plugins'

interface IContentrainField {
  fieldId: string
  fieldType: string
  componentId: string
  validations?: {
    'required-field'?: {
      value: boolean
    }
  }
  options?: {
    reference?: {
      form?: {
        reference?: {
          value: string
        }
      }
    }
  }
}

interface IContentrainModel {
  name: string
  modelId: string
  fields: IContentrainField[]
  type: 'JSON' | 'MD'
}

export async function generateTypes(options: IGenerateTypesOptions = {}): Promise<IGenerateTypesResult> {
  const rootDir = options.rootDir || process.cwd()
  const modelsDir = options.modelsDir || CONTENTRAIN_PATHS.models
  const outputFile = options.output || 'src/types/contentrain.d.ts'

  async function generate() {
    try {
      await pluginManager.runHook('beforeGenerate')
      
      // 1. Metadata'yÄ± oku
      const metadataPath = join(rootDir, modelsDir, 'metadata.json')
      const metadataContent = await readFile(metadataPath, 'utf-8')
      const metadata = JSON.parse(metadataContent) as IContentrainModel[]

      // 2. Her model iÃ§in field tanÄ±mlarÄ±nÄ± oku
      const models = await Promise.all(
        metadata.map(async (model) => {
          const modelPath = join(rootDir, modelsDir, `${model.modelId}.json`)
          const modelContent = await readFile(modelPath, 'utf-8')
          const fields = JSON.parse(modelContent) as IContentrainField[]
          return { ...model, fields }
        })
      )

      // 3. Tip tanÄ±mlarÄ±nÄ± oluÅŸtur
      const typeDefinitions = `// Generated by @contentrain/sdk
import type { IBaseModel } from '@contentrain/sdk'

${models.map(generateModelInterface).join('\n\n')}

export interface ContentrainTypeMap {
${models.map(m => `  '${m.modelId}': I${toPascalCase(m.modelId)}`).join('\n')}
}

export type ModelId = keyof ContentrainTypeMap`

      // Tip dosyasÄ±nÄ± oluÅŸtur
      await mkdir(dirname(outputFile), { recursive: true })
      await writeFile(outputFile, typeDefinitions, 'utf-8')

      await pluginManager.runHook('afterGenerate', { success: true })
      return { success: true }
    } catch (error) {
      const result = { 
        success: false, 
        error: error instanceof Error ? error.message : String(error)
      }
      await pluginManager.runHook('afterGenerate', result)
      return result
    }
  }

  // Watch mode
  if (options.watch) {
    const watchDir = join(rootDir, modelsDir)
    
    const watcher = watch(watchDir, (eventType, filename) => {
      if (filename && /\.(json|md)$/.test(filename)) {
        console.log(`ðŸ“ Model deÄŸiÅŸikliÄŸi algÄ±landÄ±: ${filename}`)
        generate().catch(error => {
          console.error('âŒ Tip Ã¼retimi hatasÄ±:', error)
        })
      }
    })

    // Cleanup iÃ§in
    process.on('SIGINT', () => {
      watcher.close()
      process.exit(0)
    })
  }

  return generate()
}

function generateModelInterface(model: IContentrainModel): string {
  const fields = model.fields
    .map(field => {
      const fieldType = getTypeForField(field)
      const isRequired = field.validations?.['required-field']?.value
      const fieldName = toCamelCase(field.fieldId)
      
      // Ä°liÅŸki alanÄ± ise referans tipini de ekle
      if (field.fieldType === 'relation' && field.options?.reference?.form?.reference?.value) {
        const refModel = field.options.reference.form.reference.value
        const refType = `I${toPascalCase(refModel)}`
        return [
          `  ${fieldName}${isRequired ? '' : '?'}: string${field.componentId === 'one-to-many' ? '[]' : ''}`,
          `  ${fieldName}Data?: ${refType}${field.componentId === 'one-to-many' ? '[]' : ''}`
        ].join('\n')
      }

      return `  ${fieldName}${isRequired ? '' : '?'}: ${fieldType}`
    })
    .join('\n')

  return `export interface I${toPascalCase(model.modelId)} extends IBaseModel {
${fields}
}`
}

function getTypeForField(field: IContentrainField): string {
  switch (field.fieldType) {
    case 'string':
      return 'string'
    case 'number':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'array':
      return 'string[]'
    case 'relation':
      return field.componentId === 'one-to-many' ? 'string[]' : 'string'
    default:
      return 'any'
  }
}

function toPascalCase(str: string): string {
  return str.split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}

function toCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase())
} 